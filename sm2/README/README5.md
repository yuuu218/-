### 一、名称：签名攻击-延展性攻击  
### 二、简介：  
    比特币的区块链如何保证一个交易有效并且不被修改：每个交易都必须签名才能花费输入（UTXO）；所有交易的哈希以Merkle Tree计算并存储到区块头。  
    假设有一个输入和一个输出，它类似：tx = … input#index … signature … output-script …,
而整个交易的哈希可直接根据交易本身计算：tx-hash = dhash(tx)  
因为只有私钥持有人才能正确地签名，所以，只要签名是有效的，tx本身就应该固定下来。  
但问题出在签名算法上。ECDSA签名算法基于私钥计算的签名实际上是两个整数，记作(r, s)，但由于椭圆曲线的对称性，(r, -s mod N)实际上也是一个有效的签名（N是椭圆曲线的固定参数之一）。
换句话说，对某个交易进行签名，总是可以计算出两个有效的签名，并且这两个有效的签名还可以互相计算出来。
黑客可以在某一笔交易发出但并未落块的时间内，对签名进行修改，使之仍是一个有效的交易。注意黑客并无法修改任何输入输出的地址和金额，仅能修改签名。但由于签名的修改，使得整个交易的哈希
被改变了。如果修改后的交易先被打包，虽然原始交易会被丢弃，且并不影响交易安全，但这个延展性攻击可用于攻击交易所。  
### 三、完成人：张琴心  
### 四、项目代码说明  
    本项目的基础是实现SM2签名算法，在此基础上将得到的签名（r,s）经过求反得到有效签名（r,-s），故利用了项目二实现的随机生成k时的SM2签名及验证算法，再定义了一个延展性攻击函数
def Malleability()。  
    为实现椭圆曲线的运算，需要一些基本的函数，如素数检测、字节和int的转换、求最大公约数、求乘法逆元等，本代码的前面部分实现了这些基础函数。其后定义了椭圆曲线密码类，
用以实现一般的ECC运算：加法、乘法、求反等。再然后定义了SM2类继承ECC，实现SM2算法的签名、验签等。最后是与本项目直接相关的延展性攻击函数。  
### 五、运行指导：利用PyCharm在安装了所需模块的前提下直接run .py文件即可  
### 六、运行截图  
两签名均通过验证  
![image](https://github.com/yuuu218/Innovation-pioneering/blob/main/image/sm2_11.png)

