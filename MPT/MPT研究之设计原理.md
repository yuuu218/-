**MPT研究之设计原理**

尽管前缀树可以起到维护 Key-Value 数据的目的，但是其具有十分明显的局限性。无论是查询操作，还是对数据的增删改，不仅效率低下，且存储空间浪费严重。因此，以太坊对其进行了改进，新增了几种不同类型的树节点，以尽量压缩整体的树高、降低操作的复杂度。

**一．节点分类**

在以太坊的 MPT 树中，树节点可以分为以下四类：

空节点（nil）；分支节点（fullNode）；叶子节点（shortNode）；扩展节点（shortNode）。

它们各自在以太坊客户端源码中的定义如下：

type (

fullNode struct {

Children [17]node // Actual trie node data to encode/decode (needs custom encoder)

flags nodeFlag

}

shortNode struct {

Key []byte

Val node

flags nodeFlag

}

hashNode []byte

valueNode []byte

)//nilValueNode用于折叠内部trie节点进行散列，因为未设置的子项需要正确序列化。

var nilValueNode = valueNode(nil)

// nodeFlag包含关于节点的缓存相关元数据

type nodeFlag struct {

hash hashNode // cached hash of the node (may be nil)

dirty bool // whether the node has changes that must be written to the database

}

注意到，叶子节点和扩展节点在源码实现中是由同一个数据结构表示的。如果一个节点是叶子节点，那么它的 Val 字段是一个 valueNode，即它表示相应键 Key 对应的 值 Value；如果一个节点是扩展节点，那么它的 Val 字段是 hashNode，即它表示下一个节点的哈希，类似于指针指向下一个节点。nodeFlag字段记录了当前节点的哈希以及当前节点是否被修改过的标志。注意到，hashNode存在的作用是为了当用户需要从数据库中加载MPT树时，不需要加载整颗完整的树，只需要加载用到的部分，剩下不需要加载的直接用它的哈希来代替即可。

MPT 同样把 Key-Value 数据项的 Key 编码在树的路径中，但是如果对 Key 以字节为单位进行拆分，那么就会导致分支节点产生的分支太多（极端情况下需要 256 个分支）。因此在以太坊中，在进行树操作之前，首先会进行一个 Key 编码的转换（后面会详述），主要是将一个字节的高低四位内容分拆成两个字节存储。此时，对于一个分支节点 fullNode，只需要存储 16 个分支，另外对于源码的 fullNode 中 Children 的最后一项，它可以是一个 valueNode。

另外，对于原始的前缀树，它会存在键 Key 的路径过长的问题，因此就会出现严重的存储空间浪费的情况。MPT利用shortNode 实现了编码路径的压缩。

下面给出了一个 MPT 的例子：

![](https://github.com/yuuu218/Innovation-pioneering/blob/main/image/M1.png?raw=true)

**二．Key编码**

在以太坊中，MPT 树的 Key 值共有三种不同的编码方式，以满足不同场景的不同需求，在这里单独作为一节进行介绍。

三种编码方式分别为：

Raw编码（外部输入）；Hex编码（内存）；Hex-Prefix编码（磁盘）。

1.Raw编码

Raw编码就是原生的 Key 值，不做任何改变。这种编码方式的 Key，是MPT对外提供接口的默认编码方式。

比如，外部输入的一个键值对为｛“cat”: “dog”｝，那么这个数据 Key 值的编码为 [‘c’，‘a’，‘t’] ，转换成 ASCII 码的表示方式就是 [63，61，74]。

另外，需要注意的是，外部输入的数据通常不是简单的字符串形式，它可能是一个复杂的数据结构。因此，这些输入数据通常会经过 RLP 编码之后，才能作为传入 Hex 编码的键值对。举个例子，一个外部输入可能是｛Address(0x123456)：100｝，它的 Key 值为 Address(0x123456)，假设它经过 RLP 编码后的结果为 0xC2123456，那么其实在将它传入 Hex 编码所用到的 Key 值为 0xC2123456 而不是 Address(0x123456)。同样地，不仅 Key 值的部分需要进行 RLP 编码，最终记录的 Value 值部分也需要进行 RLP 编码。

2.Hex编码

在介绍分支节点的时候，我们提到，为了减少分支节点孩子的个数，需要将Key 的编码进行转换，将原 Key 的高低四位分拆成两个字节进行存储。这种转换后的 Key 的编码方式，就是 Hex 编码。Hex 编码是 Key 在内存中的存储形式。

Raw编码向Hex编码的转换规则如下：

将Raw编码的每个字符，根据高4位低4位拆成两个字节；

若该 Key 对应的节点存储的是真实的数据项内容（即该节点是叶子节点），则在末位添加一个ASCII值为16的字符作为终止标志符；

若该 Key 对应的节点存储的是另外一个节点的哈希索引（即该节点是扩展节点），则不加任何字符；

举个例子，Key为 [‘c’，‘a’，‘t’]（[63，61，74]），Value为数据项，其Hex编码为[3, 15, 3, 13, 4, 10, 16]；若 Value 为另一个节点的哈希索引，其Hex编码为[3, 15, 3, 13, 4, 10]。

在以太坊的Trie模块中，Key和Value都是 []byte 类型。如果要使用其它类型，需要将其转换成 []byte 类型（RLP编码进行转换）。但是，在内存中Key的最小单位不是 byte 而是 nibble，而 nibble 实际上就是一个4位的二进制数。因此，byte型的Key值当存储在内存中时，需要将其转变为nibble型，也就是上面说的Raw编码向Hex编码转换，即根据高4位低4位进行拆成。由于go语言中实际上是没有nibble 类型的，因此 niblle 实际上也是用 byte 进行表示，只不过它的高4位都为0。

3.HP编码

在介绍叶子节点和扩展节点时，我们介绍了这两种节点定义是共享的（它们是由同一个数据结构 shortNode 表示的），即便持久化到数据库中，存储的方式也是一致的。那么当节点加载到内存是，同样需要通过一种额外的机制来区分节点的类型。于是以太坊就提出了一种HP编码对存储在数据库中的叶子和扩展节点的 Key 进行编码区分。同时，将这两类节点从内存中持久化到磁盘中之前，需要进行相应的编码转换：

Hex编码向HP编码的转换规则如下：

若原Key的末尾字节的值为16（即该节点是叶子节点），去掉该字节；

在Key之前增加一个nibble（半字节），其中最低位用来编码原本Key长度的奇偶信息，Key长度为奇数，则该位为1；低2位中编码一个特殊的终止标记符，若该节点为叶子节点，则该位为1；具体内容如下：

\| 比特 \| 节点类型 \| 奇偶\|

\| ---- \| ---- \| ----\|

\| 0000 \| 扩展节点\| 偶数\|

\| 0001 \| 扩展节点\| 奇数\|

\| 0010 \| 叶子节点\| 偶数\|

\| 0011 \| 叶子节点\| 奇数\|

若原本Key的长度为奇数（原本为奇数个nibble，那么去掉末尾 nibble 16 再增加一个 nibble 之后仍然是奇数个nibble，无法合并成byte，因此需要添加额外的半字节），则在Key之前再增加一个值为0x0的半字节；

最后将Key的内容作压缩，两个nibble合并为一个字节；

若Hex编码为 [3, 15, 3, 13, 4, 10, 16]，则HP编码的值为 [32, 63, 61, 74]。

类似地，从磁盘中读取 Key 到内存中时，将HP编码转化为Hex编码的过程就是上面的反过程。

4.转换关系

这几种编码的转换关系如下图所示：

![](https://github.com/yuuu218/Innovation-pioneering/blob/main/image/M2.png?raw=true)

Raw编码：这是外界输入的编码方式，通常对于一个复杂类型的变量，经过RLP编码后的结果便可以作为Raw编码输入。当其要被存储在内存中的MPT树上的时候，它将会被转化为Hex编码形式。

Hex编码：这是数据被存储在内存中的MPT树上的编码方式，它以nibble为单位。当树节点要被持久化到磁盘中的时候，需要将Hex编码转化为HP编码。

HP编码：这是数据被存储在磁盘中的编码方式，它以byte为单位。当树节点从磁盘中读入内存时，需要将HP编码转化为Hex编码。

以上所说的编码方式均是对 Key 值进行编码，而对 Value 值则直接采用它的RLP编码。

**三．安全的MPT**

以上介绍的MPT树，可以用来存储内容为任何长度的 Key-Value 数据项。倘若数据项的Key长度没有限制时，当树中维护的数据量较大时，仍然会造成整棵树的深度变得越来越深，会造成以下影响：

查询一个节点可能会需要许多次IO读取，效率低下；

系统易遭受Dos攻击，攻击者可以通过在合约中存储特定的数据，“构造”一棵拥有一条很长路径的树，然后不断地调用SLOAD指令读取该树节点的内容，造成系统执行效率极度下降；

所有的Key其实是一种明文的形式进行存储；

为了解决以上问题，在以太坊中对MPT再进行了一次封装，对数据项的Key进行了一次哈希计算，因此最终作为参数传入到MPT接口的数据项其实是(SHA3(Key), Value)

1.优势

传入MPT接口的Key是固定长度的（32字节），可以避免出现树中出现长度很长的路径；

2.劣势

每次树操作需要增加一次哈希计算；

需要在数据库中存储额外的SHA3(Key)与Key之间的对应关系；

**四．状态提交（持久化存储）**

对于被加载到内存中的MPT树，Geth客户端应该提供以下功能：

Get：获取MPT树中相应Key对应的Value

Insert：插入一个键值对到MPT树中，同时对修改节点的dirty位标记为true

Delete：从MPT树1中删除一个键值对，同时对修改节点的dirty位标记为true

Update：Insert和Delete操作的结合

除了上述操作之外，以太坊的MPT需要实现将存储到内存中的MPT树持久化到本地磁盘中的功能，即Commit。在提交完成后，所有变脏的树节点会重新进行哈希计算，并且将新内容写入数据库；最终新的根节点哈希将被作为MPT的最新状态被返回。

需要注意到的是，对一个节点进行提交是一个递归的操作，它会首先计算这个节点所有变脏的孩子节点的哈希，并将这些孩子节点进行提交，之后再修改该节点的 Value 字段指向新的孩子节点的哈希，最后计算当前节点的哈希值。同时，对孩子节点的哈希值计算过程中，可能需要计算孩子节点的孩子（如果存在且被修改的话）相应的哈希，因此这个过程是一个递归的过程。下图是一个例子：

![](https://github.com/yuuu218/Innovation-pioneering/blob/main/image/M3.png?raw=true)

如果要将这棵树进行可持久化存储，需要首先计算得到左下角叶子节点的哈希 0xaa（这同样也是它存储在持久化数据库中的索引），再计算粉色节点的哈希 0xcc，然后由得到的这两个节点计算分支节点的哈希 0xdd，最后计算根节点的哈希 0xee。

1.节点过老的判断依据

Geth客户端会清除在内存中保留时间过长且未被使用到的的节点，在判断一个节点在内存中存在时间是否过长的依据是：

(1)该节点未被修改；

(2)当前MPT的计数器减去节点的诞生标志超过了固定的上限；

(3)每当MPT调用一次Commit函数，MPT的计数器发生自增；

2.快速计算所维护数据集哈希标识

这个特点体现在单节点哈希计算的第一步，即在节点哈希计算之前会对该节点的状态进行判断，只有当该节点的内容变脏，才会进行哈希重计算、数据库持久化等操作。如此一来，在某一次事务操作中，对整棵MPT树的部分节点的内容产生了修改，那么一次哈希重计算，仅需对这些被修改的节点、以及从这些节点到根节点路径上的节点进行重计算，便能重新获得整棵树的新哈希。

3.快速状态回滚

在公链的环境下，采用POW算法是可能会造成分叉而导致区块链状态进行回滚的。在以太坊中，由于出块时间短，这种分叉的几率很大，区块链状态回滚的现象很频繁。如下图所示：

![](https://github.com/yuuu218/Innovation-pioneering/blob/main/image/M4.png?raw=true)

在上图中，一个节点的内容由27变为45，就需要新增4个节点而不会修改原来的节点（实际过程中可能不止4个），就对应成创建了一条由蓝线圈出的新路径。通过结合新增的节点以及橙色圈出的未被修改的节点，可以构造一棵新树，而旧路径依旧保留。因此，通过旧stateRoot，我们依旧能够查询到在过去区块上该节点的值为27。所以，在以太坊中，发生分叉而进行世界状态回滚时，仅需要用旧的MPT根节点作为入口，即可完成状态回滚。

4.修剪区块

上述提到的状态回滚，仅仅保留最近几个区块的历史状态，并不会保留所有的历史状态数据。试想，如果保留所有的历史状态数据，随着以太坊的长时间运行，以太坊数据将变得非常庞大。

为了减轻数据存储的压力，以太坊提出了修剪区块的概念，即利用trie模块中的trie.Database对缓存节点进行引用计数，并在blockchain模块中进行相应的引用和解引用操作（某个节点不再被其他节点引用时便直接从可持久化存储中释放该节点）。如此释放了大量不需要保存的历史数据的存储空间。

一般用户在full模式下运行geth客户端会默认进行修剪区块的操作，当然，用户也可以选择在archive模式下运行geth客户端，在这种情况下，geth客户端将会保存所有的历史状态数据，不会进行区块的修剪。我们可以利用archive模式下的数据，复现历史区块上的交易，但是需要注意的是，这个模式下，存储的数据量是相当庞大的。

**五．轻节点扩展**

MPT能够提供的一个重要功能 - 默克尔证明，使用默克尔证明能够实现轻节点的扩展。

1.什么是轻节点

在以太坊或比特币中，一个参与共识的全节点通常会维护整个区块链的数据，每个区块中的区块头信息，所有的交易，回执信息等。由于区块链的不可篡改性，这将导致随着时间的增加，整个区块链的数据体量会非常庞大。运行在个人PC或者移动终端的可能性显得微乎其微。为了解决这个问题，一种轻量级的，只存储区块头部信息的节点被提出。这种节点只需要维护链中所有的区块头信息（一个区块头的大小通常为几十个字节，普通的移动终端设备完全能够承受出）。

在公链的环境下，仅仅通过本地所维护的区块头信息，轻节点就能够证明某一笔交易是否存在与区块链中；某一个账户是否存在与区块链中，其余额是多少等功能。

2.什么是默克尔证明

默克尔证明指一个轻节点向一个全节点发起一次证明请求，询问全节点完整的默克尔树中，是否存在一个指定的节点；全节点向轻节点返回一个默克尔证明路径，由轻节点进行计算，验证存在性。

3.默克尔证明过程

如有棵如下图所示的默克尔树，如果某个轻节点想要验证 9Dog:64 这个树节点是否存在与默克尔树中，只需要向全节点发送该请求，全节点会返回一个 1FXq:18, ec20, 8f74 的一个路径。得到路径之后，轻节点利用 9Dog:64 与 1FXq:18 求哈希，在与 ec20 求哈希，最后与 8f74 求哈希，得到的结果与本地维护的根哈希相比，是否相等。若相等，则证明该树节点存在于默克尔树中；否则，不存在。

![](https://github.com/yuuu218/Innovation-pioneering/blob/main/image/M5.png?raw=true)

![](https://github.com/yuuu218/Innovation-pioneering/blob/main/image/M6.png?raw=true)

4.默克尔证明安全性

(1)若全节点返回的是一条恶意的路径？

试图为一个不存在于区块链中的节点伪造一条合法的默克尔路径，使得最终的计算结果与区块头中的默克尔根哈希相同。由于哈希的计算具有不可预测性，使得一个恶意的全节点想要为一条不存在的节点伪造一条伪路径使得最终计算的根哈希与轻节点所维护的根哈希相同是不可能的。

(2)为什么不直接向全节点请求该节点是否存在于区块链中？

由于在公链的环境中，无法判断请求的全节点是否为恶意节点，因此直接向某一个或者多个全节点请求得到的结果是无法得到保证的。但是轻节点本地维护的区块头信息，是经过工作量证明验证的，也就是经过共识一定正确的，若利用全节点提供的默克尔路径，与代验证的节点进行哈希计算，若最终结果与本地维护的区块头中根哈希一致，则能够证明该节点一定存在于默克尔树中。

5.简单支付验证

在以太坊中，利用默克尔证明在轻节点中实现简单支付验证，即在无需维护具体交易信息的前提下，证明某一笔交易是否存在于区块链中。

参考文献：https://blog.csdn.net/qq_55179414/article/details/118935827
